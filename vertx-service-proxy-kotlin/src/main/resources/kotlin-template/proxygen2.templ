
@declare{'methodBody'}
	@code{hasParams = !method.params.isEmpty()}
	@code{lastParam = hasParams ? method.params.get(method.params.size() - 1) : null}
	@code{hasResultHandler=(lastParam != null) && (lastParam.type.kind == CLASS_HANDLER) && (lastParam.type.args[0].kind == CLASS_ASYNC_RESULT)}
	@code{count=0}
  @if{hasResultHandler}
  if (closed) {\n
    @{lastParam.name}.handle(Future.failedFuture(new IllegalStateException("Proxy is closed")))\n
  @if{method.fluent}
    return this\n
  @else{}
    return\n
  @end{}
  }\n
  @else{}
  if (closed) {\n
    throw IllegalStateException("Proxy is closed")\n
  }\n
  @end{}
@if{method.proxyClose}
  closed = true\n
@end{}

	  val _json = JsonObject()\n
	@foreach{param: method.params}
		@if{!hasResultHandler || (count++ != method.params.size() - 1)}
			@if{param.type.name == 'char'}
    _json.put("@{param.name}", @{param.name}.toInt())\n
			@else{param.type.name == 'java.lang.Character'}
    _json.put("@{param.name}", @{param.name} == null ? null : @{param.name}.toInt())\n
			@else{param.type.kind == CLASS_ENUM}
    _json.put("@{param.name}", @{param.name} == null ? null : @{param.name}.toString())\n
			@else{param.type.kind == CLASS_LIST}
				@if{param.type.args[0].kind == CLASS_DATA_OBJECT}
    _json.put("@{param.name}", JsonArray(@{param.name}.asSequence().map(@{param.type.args[0].simpleName}::toJson).toList()))\n
				@else{}
    _json.put("@{param.name}", JsonArray(@{param.name}))\n
				@end{}
			@else{param.type.kind == CLASS_SET}
				@if{param.type.args[0].kind == CLASS_DATA_OBJECT}
    _json.put("@{param.name}", JsonArray(@{param.name}.asSequence().map(@{param.type.args[0].simpleName}::toJson).toList()))\n
				@else{}
    _json.put("@{param.name}", JsonArray(ArrayList<>(@{param.name})))\n
				@end{}
			@else{param.type.kind == CLASS_MAP}
    _json.put("@{param.name}", JsonObject(convertMap(@{param.name})))\n
			@else{param.type.kind == CLASS_DATA_OBJECT}
    _json.put("@{param.name}", @{param.name} == null ? null : @{param.name}.toJson())\n
			@else{}
    _json.put("@{param.name}", @{param.name})\n
			@end{}
		@end{}
	@end{}

    val _deliveryOptions = if((options != null))DeliveryOptions(options) else DeliveryOptions()\n
    _deliveryOptions.addHeader("action", "@{method.name}")\n
	@if{hasResultHandler}
		@code{resultType=lastParam.type.args[0].args[0]}
		@code{resultKind=resultType.kind}
    vertx.eventBus().
@if{resultKind == CLASS_LIST || resultKind == CLASS_SET}
<JsonArray>
@else{resultKind == CLASS_DATA_OBJECT}
<JsonObject>
@else{resultKind == CLASS_ENUM}
<String>
@else{resultType.simpleName == 'Integer'}
<Int>
@else{}
<@{resultType.simpleName}>
@end{}

send(address, _json, _deliveryOptions, res -> {\n
      if (res.failed()) {\n
        @{lastParam.name}.handle(Future.failedFuture(res.cause()))\n
      } else {\n
				@if{resultKind == CLASS_LIST}
					@if{resultType.args[0].name == 'java.lang.Character'}
        @{lastParam.name}.handle(Future.succeededFuture(convertToListChar(res.result().body())))\n
					@else{resultType.args[0].kind == CLASS_DATA_OBJECT}
        @{lastParam.name}.handle(Future.succeededFuture(res.result().body().stream().map(o -> o instanceof Map ? new @{resultType.args[0].simpleName}(new JsonObject((Map) o)) : new @{resultType.args[0].simpleName}((JsonObject) o)).collect(Collectors.toList())))\n
					@else{}
        @{lastParam.name}.handle(Future.succeededFuture(convertList(res.result().body().getList())))\n
					@end{}
				@else{resultKind == CLASS_SET}
					@if{resultType.args[0].name == 'java.lang.Character'}
        @{lastParam.name}.handle(Future.succeededFuture(convertToSetChar(res.result().body())))\n
					@else{resultType.args[0].kind == CLASS_DATA_OBJECT}
        @{lastParam.name}.handle(Future.succeededFuture(res.result().body().stream().map(o -> o instanceof Map ? new @{resultType.args[0].simpleName}(new JsonObject((Map) o)) : new @{resultType.args[0].simpleName}((JsonObject) o)).collect(Collectors.toSet())))\n
					@else{}
        @{lastParam.name}.handle(Future.succeededFuture(convertSet(res.result().body().getList())))\n
					@end{}
				@else{resultKind == CLASS_API && resultType.proxyGen}
        String addr = res.result().headers().get("proxyaddr")\n
        @{lastParam.name}.handle(Future.succeededFuture(ProxyHelper.createProxy(@{resultType.simpleName}.class, vertx, addr)))\n
				@else{resultKind == CLASS_DATA_OBJECT}
        @{lastParam.name}.handle(Future.succeededFuture(res.result().body() == null ? null : new @{resultType.simpleName}(res.result().body())))\n
                @else{resultKind == CLASS_ENUM}
        @{lastParam.name}.handle(Future.succeededFuture(res.result().body() == null ? null : @{resultType.simpleName}.valueOf(res.result().body())))\n
				@else{}
        @{lastParam.name}.handle(Future.succeededFuture(res.result().body()))\n
				@end{}
      }\n
    })\n
	@else{}
    vertx.eventBus().send(address, _json, _deliveryOptions)\n
	@end{}

@end{}


@declare{'startMethodTemplate'}
override fun @if{method.typeParams.size() > 0}
		<@foreach{typeVar:method.typeParams}@{typeVar}@end{', '}>
	 @end{}@{method.name}(@foreach{param: method.params} @{param.name} : @{param.type.simpleName}@end{', '}) @if{method.returnType.simpleName != "void"} { :@{method.returnType.simpleName}}@end{} {
@end{}

/*\n
* Copyright 2014 Red Hat, Inc.\n
*\n
* Red Hat licenses this file to you under the Apache License, version 2.0\n
* (the "License") you may not use this file except in compliance with the\n
* License. You may obtain a copy of the License at:\n
*\n
* http://www.apache.org/licenses/LICENSE-2.0\n
*\n
* Unless required by applicable law or agreed to in writing, software\n
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n
* License for the specific language governing permissions and limitations\n
* under the License.\n
*/\n\n
package @{ifacePackageName}\n
\n
import @{ifaceFQCN}\n
import io.vertx.core.eventbus.DeliveryOptions\n
import io.vertx.core.Vertx\n
import io.vertx.core.Future\n
import io.vertx.core.json.JsonObject\n
import io.vertx.core.json.JsonArray\n
import java.util.ArrayList\n
import java.util.HashSet\n
import java.util.List\n
import java.util.Map\n
import java.util.Set\n
import java.util.stream.Collectors\n
import java.util.function.Function\n
//import io.vertx.serviceproxy.ProxyHelper\n
//import io.vertx.serviceproxy.ServiceException\n
//import io.vertx.serviceproxy.ServiceExceptionMessageCodec\n
@foreach{importedType:importedTypes}
	@if{!importedType.packageName.equals("java.lang")}
		import @{importedType}\n
	@end{}
@end{}
\n
/*\n
  Generated Proxy code - DO NOT EDIT\n
  @author Roger the Robot\n
*/\n
//@SuppressWarnings({"unchecked", "rawtypes"})\n
class @{ifaceSimpleName}VertxEBProxy(private val vertx: Vertx, private val address : String, private val options : DeliveryOptions? = null) : @{ifaceSimpleName} {\n
    var closed : Boolean = false \n
\n
  @foreach{method:methods}
    @if{!method.staticMethod}
  @includeNamed{'startMethodTemplate';method:method}\n
        @if{!method.proxyIgnore}@includeNamed{'methodBody';method:method}@end{}
        @if{method.fluent}
    return this;\nf
        @end{}
  }\n\n
    @end{}
  @end{}
\n
}

